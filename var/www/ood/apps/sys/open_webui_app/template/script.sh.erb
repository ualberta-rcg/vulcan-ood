#!/bin/bash

# Ensure script is executable
chmod +x "$0" 2>/dev/null || true

echo "[script.sh.erb] Starting Open WebUI Server with nginx proxy"

# Change to user's home directory
cd "${HOME}"
echo "[script.sh.erb] Changed working directory to ${HOME}"

# Load required modules (ensure they're loaded)
echo "[script.sh.erb] Loading required modules..."
module purge

# Load Python module (required for Open WebUI)
if module load python/3.12.4; then
  echo "[script.sh.erb] Successfully loaded Python 3.12.4"
else
  echo "[script.sh.erb] Failed to load Python module"
  exit 1
fi

# Load other required modules
if module load rust/1.91.0; then
  echo "[script.sh.erb] Successfully loaded Rust 1.91.0"
else
  echo "[script.sh.erb] WARNING: Failed to load Rust module (may not be critical)"
fi

if module load arrow; then
  echo "[script.sh.erb] Successfully loaded Arrow"
else
  echo "[script.sh.erb] WARNING: Failed to load Arrow module (may not be critical)"
fi

if module load opencv; then
  echo "[script.sh.erb] Successfully loaded OpenCV"
else
  echo "[script.sh.erb] WARNING: Failed to load OpenCV module (may not be critical)"
fi

# Activate the virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
  echo "[script.sh.erb] Activating virtual environment..."
  if [[ -f "${WEBUI_VENV_DIR}/bin/activate" ]]; then
    source "${WEBUI_VENV_DIR}/bin/activate"
    echo "[script.sh.erb] Virtual environment activated: $VIRTUAL_ENV"
  else
    echo "[script.sh.erb] ERROR: Virtual environment not found at ${WEBUI_VENV_DIR}"
    exit 1
  fi
else
  echo "[script.sh.erb] Virtual environment already active: $VIRTUAL_ENV"
fi

# Verify open-webui command is available
if ! command -v open-webui >/dev/null 2>&1; then
  echo "[script.sh.erb] ERROR: open-webui command not found in PATH"
  echo "[script.sh.erb] PATH: $PATH"
  echo "[script.sh.erb] VIRTUAL_ENV: $VIRTUAL_ENV"
  echo "[script.sh.erb] Checking if open-webui is installed..."
  pip show open-webui || echo "[script.sh.erb] open-webui package not found"
  exit 1
fi

echo "[script.sh.erb] Found open-webui command: $(which open-webui)"

# Verify nginx binary exists
if [ ! -f "${NGINX_BINARY_PATH}" ]; then
  echo "[script.sh.erb] ERROR: Nginx binary not found at ${NGINX_BINARY_PATH}"
  echo "[script.sh.erb] Nginx should have been built in before.sh.erb"
  exit 1
fi

# Verify nginx has sub_filter module
if ! "${NGINX_BINARY_PATH}" -V 2>&1 | grep -q "http_sub_module"; then
  echo "[script.sh.erb] ERROR: Nginx binary missing http_sub_module"
  exit 1
fi

echo "[script.sh.erb] Nginx binary verified: ${NGINX_BINARY_PATH}"

# Port configuration
# PROXY_PORT is the OOD-assigned port (what OOD connects to)
# WEBUI_INTERNAL_PORT is for Open WebUI (internal, not exposed)
export PROXY_PORT="${port}"
export WEBUI_INTERNAL_PORT=$((port + 1))
export WEBUI_INTERNAL_HOST="127.0.0.1"
export PROXY_HOST="0.0.0.0"

# Set Open WebUI environment variables (for internal instance)
export WEBUI_PORT="${WEBUI_INTERNAL_PORT}"
export WEBUI_HOST="${WEBUI_INTERNAL_HOST}"
export WEBUI_DATA_DIR="${WEBUI_WORKDIR}"

# Disable authentication (since we're behind OOD's auth)
export WEBUI_AUTH="false"
export ENABLE_SIGNUP="false"
export WEBUI_SECRET_KEY="$(openssl rand -hex 32)"
export WEBUI_NAME="Open WebUI"

# Remove WEBUI_URL and ROOT_PATH - let Open WebUI think it's at root
# The proxy will handle path rewriting

echo "[script.sh.erb] PROXY_PORT=${PROXY_PORT} (OOD connects here)"
echo "[script.sh.erb] WEBUI_INTERNAL_PORT=${WEBUI_INTERNAL_PORT} (internal)"
echo "[script.sh.erb] WEBUI_DATA_DIR=${WEBUI_DATA_DIR}"
echo "[script.sh.erb] WEBUI_AUTH=${WEBUI_AUTH}"

# Create nginx configuration file
# Create temp directories for nginx (in job directory)
mkdir -p "${WEBUI_WORKDIR}/client_body_temp"
mkdir -p "${WEBUI_WORKDIR}/proxy_temp"

echo "[script.sh.erb] Creating nginx configuration..."
cat > "${WEBUI_WORKDIR}/nginx.conf" <<NGINX_CONF
worker_processes 1;
error_log ./nginx_error.log;
pid ./nginx.pid;

events {
    worker_connections 1024;
}

http {
    access_log ./nginx_access.log;
    
    # Set temp directories (relative to config file location)
    # Only include modules that were compiled (fastcgi/uwsgi/scgi were excluded)
    client_body_temp_path ./client_body_temp;
    proxy_temp_path ./proxy_temp;
    
    upstream webui_backend {
        server ${WEBUI_INTERNAL_HOST}:${WEBUI_INTERNAL_PORT};
    }
    
    server {
        listen ${PROXY_PORT};
        server_name _;
        
        # API endpoints - NO sub_filter (pass through unchanged)
        # This matches the nginx pattern from GitHub discussion
        sub_filter '"/' '"./';
        sub_filter "'/" "'./";
        sub_filter 'href="/' 'href="./';
        sub_filter 'src="/' 'src="./';
        sub_filter 'action="/' 'action="./';
        sub_filter 'url("/' 'url("./';
        sub_filter 'url(\'/' 'url(\'./';
        sub_filter '"/api/' '"./api/';
        sub_filter "'/api/" "'./api/";
        sub_filter '"/_app/' '"./_app/';
        sub_filter "'/_app/" "'./_app/";
        
        # Replace ALL occurrences (critical!)
        sub_filter_once off;
        
        # API endpoints - NO sub_filter (pass through unchanged)
        # This matches the GitHub discussion pattern - API should not be modified
        location /api {
            proxy_pass http://webui_backend;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            
            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            
            proxy_read_timeout 300;
            proxy_send_timeout 300;
            proxy_buffering off;
        }
        
        # Main location with sub_filter for path rewriting
        location / {
            # Enable sub_filter for path rewriting
            # Note: text/html is default, so we don't need to include it
            sub_filter_types text/css application/javascript text/javascript;
            
            # Rewrite absolute paths to relative paths (with ./ prefix)
            # This matches the nginx pattern from GitHub discussion
            sub_filter '"/' '"./';
            sub_filter "'/" "'./";
            sub_filter 'href="/' 'href="./';
            sub_filter 'src="/' 'src="./';
            sub_filter 'action="/' 'action="./';
            sub_filter 'url("/' 'url("./';
            sub_filter 'url(\'/' 'url(\'./';
            sub_filter '"/api/' '"./api/';
            sub_filter "'/api/" "'./api/";
            sub_filter '"/_app/' '"./_app/';
            sub_filter "'/_app/" "'./_app/';
            
            # Replace ALL occurrences (critical!)
            sub_filter_once off;
            
            proxy_pass http://webui_backend;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            
            # WebSocket support (critical for Open WebUI)
            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            
            # Timeouts for long-running AI responses
            proxy_read_timeout 300;
            proxy_send_timeout 300;
            
            # Disable buffering for streaming
            proxy_buffering off;
        }
    }
}
NGINX_CONF

echo "[script.sh.erb] Nginx configuration created at ${WEBUI_WORKDIR}/nginx.conf"

# Start Open WebUI on localhost (internal)
echo "[script.sh.erb] Starting Open WebUI on ${WEBUI_INTERNAL_HOST}:${WEBUI_INTERNAL_PORT}..."
echo "[script.sh.erb] Logging to ${WEBUI_LOG_FILE}"

nohup open-webui serve \
  --host "${WEBUI_INTERNAL_HOST}" \
  --port "${WEBUI_INTERNAL_PORT}" \
  > "${WEBUI_LOG_FILE}" 2>&1 &

WEBUI_PID=$!
echo "[script.sh.erb] Open WebUI started with PID: $WEBUI_PID"

# Wait for Open WebUI to start
echo "[script.sh.erb] Waiting for Open WebUI to initialize..."
sleep 10

# Check if Open WebUI is still running
if ! kill -0 $WEBUI_PID 2>/dev/null; then
  echo "[script.sh.erb] ERROR: Open WebUI process died. Check logs:"
  echo "[script.sh.erb] =========================================="
  cat "${WEBUI_LOG_FILE}" || echo "[script.sh.erb] Could not read log file"
  echo "[script.sh.erb] =========================================="
  exit 1
fi

echo "[script.sh.erb] Open WebUI Server started successfully on port ${WEBUI_INTERNAL_PORT}"

# Start nginx proxy
echo "[script.sh.erb] Starting nginx reverse proxy on ${PROXY_HOST}:${PROXY_PORT}..."
cd "${WEBUI_WORKDIR}"

# Start nginx with our config (pid and error_log are set in config file)
# Use -e to suppress the default error log warning
"${NGINX_BINARY_PATH}" -c "${WEBUI_WORKDIR}/nginx.conf" -e "${WEBUI_WORKDIR}/nginx_error.log" &

NGINX_PID=$!
echo "[script.sh.erb] Nginx started with PID: $NGINX_PID"

# Wait for nginx to start
sleep 2

# Check if nginx is still running
if ! kill -0 $NGINX_PID 2>/dev/null; then
  echo "[script.sh.erb] ERROR: Nginx process died. Check logs:"
  echo "[script.sh.erb] =========================================="
  cat "${WEBUI_WORKDIR}/nginx_error.log" 2>/dev/null || echo "[script.sh.erb] Could not read nginx error log"
  echo "[script.sh.erb] =========================================="
  exit 1
fi

echo "[script.sh.erb] Nginx proxy started successfully on port ${PROXY_PORT}"
echo "[script.sh.erb] OOD should connect to port ${PROXY_PORT}"

# Keep the script running to maintain both processes
wait $WEBUI_PID
echo "[script.sh.erb] Open WebUI Server exited, stopping nginx..."
kill $NGINX_PID 2>/dev/null || true
# Also try to stop nginx gracefully
"${NGINX_BINARY_PATH}" -s quit -c "${WEBUI_WORKDIR}/nginx.conf" 2>/dev/null || true
echo "[script.sh.erb] Nginx stopped."

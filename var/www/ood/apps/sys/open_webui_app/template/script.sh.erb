#!/bin/bash

# Ensure script is executable
chmod +x "$0" 2>/dev/null || true

echo "[script.sh.erb] Starting Open WebUI Server with uvicorn proxy"

# Change to user's home directory
cd "${HOME}"
echo "[script.sh.erb] Changed working directory to ${HOME}"

# Load required modules (ensure they're loaded)
echo "[script.sh.erb] Loading required modules..."
module purge

# Load Python module (required for Open WebUI)
if module load python/3.12.4; then
  echo "[script.sh.erb] Successfully loaded Python 3.12.4"
else
  echo "[script.sh.erb] Failed to load Python module"
  exit 1
fi

# Load other required modules
if module load rust/1.91.0; then
  echo "[script.sh.erb] Successfully loaded Rust 1.91.0"
else
  echo "[script.sh.erb] WARNING: Failed to load Rust module (may not be critical)"
fi

if module load arrow; then
  echo "[script.sh.erb] Successfully loaded Arrow"
else
  echo "[script.sh.erb] WARNING: Failed to load Arrow module (may not be critical)"
fi

if module load opencv; then
  echo "[script.sh.erb] Successfully loaded OpenCV"
else
  echo "[script.sh.erb] WARNING: Failed to load OpenCV module (may not be critical)"
fi

# Activate the virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
  echo "[script.sh.erb] Activating virtual environment..."
  if [[ -f "${WEBUI_VENV_DIR}/bin/activate" ]]; then
    source "${WEBUI_VENV_DIR}/bin/activate"
    echo "[script.sh.erb] Virtual environment activated: $VIRTUAL_ENV"
  else
    echo "[script.sh.erb] ERROR: Virtual environment not found at ${WEBUI_VENV_DIR}"
    exit 1
  fi
else
  echo "[script.sh.erb] Virtual environment already active: $VIRTUAL_ENV"
fi

# Verify open-webui command is available
if ! command -v open-webui >/dev/null 2>&1; then
  echo "[script.sh.erb] ERROR: open-webui command not found in PATH"
  echo "[script.sh.erb] PATH: $PATH"
  echo "[script.sh.erb] VIRTUAL_ENV: $VIRTUAL_ENV"
  echo "[script.sh.erb] Checking if open-webui is installed..."
  pip show open-webui || echo "[script.sh.erb] open-webui package not found"
  exit 1
fi

# Verify httpx is available (needed for proxy)
if ! python -c "import httpx" 2>/dev/null; then
  echo "[script.sh.erb] ERROR: httpx not found. Installing..."
  pip install httpx
  if ! python -c "import httpx" 2>/dev/null; then
    echo "[script.sh.erb] ERROR: Failed to install httpx"
    exit 1
  fi
fi

echo "[script.sh.erb] Found open-webui command: $(which open-webui)"

# Port configuration
# PROXY_PORT is the OOD-assigned port (what OOD connects to)
# WEBUI_INTERNAL_PORT is for Open WebUI (internal, not exposed)
export PROXY_PORT="${port}"
export WEBUI_INTERNAL_PORT=$((port + 1))
export WEBUI_INTERNAL_HOST="127.0.0.1"
export PROXY_HOST="0.0.0.0"

# Set Open WebUI environment variables (for internal instance)
export WEBUI_PORT="${WEBUI_INTERNAL_PORT}"
export WEBUI_HOST="${WEBUI_INTERNAL_HOST}"
export WEBUI_DATA_DIR="${WEBUI_WORKDIR}"

# Disable authentication (since we're behind OOD's auth)
export WEBUI_AUTH="false"
export ENABLE_SIGNUP="false"
export WEBUI_SECRET_KEY="$(openssl rand -hex 32)"
export WEBUI_NAME="Open WebUI"

# Remove WEBUI_URL and ROOT_PATH - let Open WebUI think it's at root
# The proxy will handle path rewriting

echo "[script.sh.erb] PROXY_PORT=${PROXY_PORT} (OOD connects here)"
echo "[script.sh.erb] WEBUI_INTERNAL_PORT=${WEBUI_INTERNAL_PORT} (internal)"
echo "[script.sh.erb] WEBUI_DATA_DIR=${WEBUI_DATA_DIR}"
echo "[script.sh.erb] WEBUI_AUTH=${WEBUI_AUTH}"

# Create the proxy app
echo "[script.sh.erb] Creating uvicorn proxy app..."
cat > "${WEBUI_WORKDIR}/proxy.py" <<'PROXY_EOF'
import httpx
from fastapi import FastAPI, Request, Response
from fastapi.responses import StreamingResponse

UPSTREAM = "http://127.0.0.1:WEBUI_INTERNAL_PORT_PLACEHOLDER"

app = FastAPI()

@app.api_route("/{path:path}", methods=["GET","POST","PUT","DELETE","PATCH","OPTIONS"])
async def proxy(request: Request, path: str = ""):
    # Build upstream URL
    if path:
        url = f"{UPSTREAM}/{path}"
    else:
        url = UPSTREAM
    
    # Add query string if present
    if request.query_params:
        url += "?" + str(request.query_params)
    
    # Prepare headers (exclude host, accept-encoding to get uncompressed)
    headers = {k: v for k, v in request.headers.items() if k.lower() not in ["host", "accept-encoding"]}
    # Request uncompressed content so we can modify it
    headers["accept-encoding"] = "identity"
    
    # Get request body
    body = await request.body()
    
    try:
        async with httpx.AsyncClient(follow_redirects=False, timeout=300.0) as client:
            resp = await client.request(
                request.method,
                url,
                headers=headers,
                content=body,
            )
    except Exception as e:
        return Response(
            content=f"Proxy error: {str(e)}".encode(),
            status_code=502,
        )
    
    # Process response headers
    response_headers = dict(resp.headers)
    
    # Fix redirects to use relative paths
    if "location" in response_headers:
        location = response_headers["location"]
        if location.startswith("/"):
            # Convert absolute redirect to relative
            response_headers["location"] = "." + location
    
    # Get content and handle encoding
    content_encoding = response_headers.get("content-encoding", "").lower()
    content = resp.content
    
    # If content is compressed, we need to decompress it before modifying
    import gzip
    import zlib
    
    if content_encoding == "gzip" and content:
        try:
            content = gzip.decompress(content)
            # Remove encoding headers since we're sending uncompressed
            response_headers.pop("content-encoding", None)
            response_headers.pop("content-length", None)
        except:
            pass  # If decompression fails, try to work with original content
    elif content_encoding == "deflate" and content:
        try:
            content = zlib.decompress(content)
            response_headers.pop("content-encoding", None)
            response_headers.pop("content-length", None)
        except:
            pass
    
    # Only rewrite paths in HTML/CSS/JS, NOT in JSON/API responses
    content_type = response_headers.get("content-type", "").lower()
    
    # Skip rewriting for API responses and JSON - these need to pass through unchanged
    if not any(ct in content_type for ct in ["application/json", "application/xml", "text/xml", "application/octet-stream"]):
        if any(ct in content_type for ct in ["text/html", "text/css", "application/javascript", "text/javascript"]):
            # Replace '"/' with '"./' to make paths relative with ./ prefix
            # This converts "/static/..." to "./static/..." and "/_app/..." to "./_app/..."
            # ES6 modules require ./ prefix for relative imports
            content = content.replace(b'"/', b'"./')
            # Also handle single quotes
            content = content.replace(b"'/", b"'./")
            # Handle href, src, action attributes (they also need ./ for relative paths)
            content = content.replace(b'href="/', b'href="./')
            content = content.replace(b'src="/', b'src="./')
            content = content.replace(b'action="/', b'action="./')
            # Handle CSS url() patterns
            content = content.replace(b'url("/', b'url("./')
            content = content.replace(b"url('/", b"url('./")
            # Handle JavaScript fetch/API calls - common patterns
            content = content.replace(b"fetch('/", b"fetch('./")
            content = content.replace(b'fetch("/', b'fetch("./')
            content = content.replace(b".fetch('/", b".fetch('./")
            content = content.replace(b'.fetch("/', b'.fetch("./')
            # Handle common API path patterns in JavaScript
            content = content.replace(b"'/api/", b"'./api/")
            content = content.replace(b'"/api/', b'"./api/')
            content = content.replace(b"'/_app/", b"'./_app/")
            content = content.replace(b'"/_app/', b'"./_app/')
            # Update content-length
            response_headers["content-length"] = str(len(content))
    
    return Response(
        content=content,
        status_code=resp.status_code,
        headers=response_headers,
        media_type=response_headers.get("content-type"),
    )
PROXY_EOF

# Replace placeholders in proxy.py
sed "s|WEBUI_INTERNAL_PORT_PLACEHOLDER|${WEBUI_INTERNAL_PORT}|g" "${WEBUI_WORKDIR}/proxy.py" > "${WEBUI_WORKDIR}/proxy.py.tmp" && mv "${WEBUI_WORKDIR}/proxy.py.tmp" "${WEBUI_WORKDIR}/proxy.py"

echo "[script.sh.erb] Proxy app created at ${WEBUI_WORKDIR}/proxy.py"

# Start Open WebUI on localhost (internal)
echo "[script.sh.erb] Starting Open WebUI on ${WEBUI_INTERNAL_HOST}:${WEBUI_INTERNAL_PORT}..."
echo "[script.sh.erb] Logging to ${WEBUI_LOG_FILE}"

nohup open-webui serve \
  --host "${WEBUI_INTERNAL_HOST}" \
  --port "${WEBUI_INTERNAL_PORT}" \
  > "${WEBUI_LOG_FILE}" 2>&1 &

WEBUI_PID=$!
echo "[script.sh.erb] Open WebUI started with PID: $WEBUI_PID"

# Wait for Open WebUI to start
echo "[script.sh.erb] Waiting for Open WebUI to initialize..."
sleep 10

# Check if Open WebUI is still running
if ! kill -0 $WEBUI_PID 2>/dev/null; then
  echo "[script.sh.erb] ERROR: Open WebUI process died. Check logs:"
  echo "[script.sh.erb] =========================================="
  cat "${WEBUI_LOG_FILE}" || echo "[script.sh.erb] Could not read log file"
  echo "[script.sh.erb] =========================================="
  exit 1
fi

echo "[script.sh.erb] Open WebUI Server started successfully on port ${WEBUI_INTERNAL_PORT}"

# Start uvicorn proxy
echo "[script.sh.erb] Starting uvicorn reverse proxy on ${PROXY_HOST}:${PROXY_PORT}..."
cd "${WEBUI_WORKDIR}"

nohup uvicorn proxy:app \
  --host "${PROXY_HOST}" \
  --port "${PROXY_PORT}" \
  --log-level info \
  --access-log \
  > "${WEBUI_WORKDIR}/proxy.log" 2>&1 &

PROXY_PID=$!
echo "[script.sh.erb] Proxy started with PID: $PROXY_PID"

# Wait for proxy to start
sleep 5

# Check if proxy is still running
if ! kill -0 $PROXY_PID 2>/dev/null; then
  echo "[script.sh.erb] ERROR: Proxy process died. Check logs:"
  echo "[script.sh.erb] =========================================="
  cat "${WEBUI_WORKDIR}/proxy.log" || echo "[script.sh.erb] Could not read proxy log"
  echo "[script.sh.erb] =========================================="
  exit 1
fi

echo "[script.sh.erb] Uvicorn proxy started successfully on port ${PROXY_PORT}"
echo "[script.sh.erb] OOD should connect to port ${PROXY_PORT}"

# Keep the script running to maintain both processes
wait $WEBUI_PID
echo "[script.sh.erb] Open WebUI Server exited, stopping proxy..."
kill $PROXY_PID 2>/dev/null || true
echo "[script.sh.erb] Proxy stopped."
